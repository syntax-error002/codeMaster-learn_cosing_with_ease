<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Off-Campus Interview Prep Hub</title>
    <style>
        :root {
            --gradient-1: linear-gradient(135deg, #6366f1, #8b5cf6);
            --gradient-2: linear-gradient(135deg, #3b82f6, #2dd4bf);
            --card-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.7;
        }

        .hero {
            background: var(--gradient-1);
            padding: 3rem 2rem;
            color: white;
            text-align: center;
            clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
        }

        .hero h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .quick-filters {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .container {
            max-width: 1200px;
            margin: -4rem auto 2rem;
            padding: 0 2rem;
            position: relative;
        }

        .question-card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.3s ease;
        }

        .question-card:hover {
            transform: translateY(-5px);
        }

        .company-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 50px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .company-tag img {
            width: 20px;
            height: 20px;
        }

        .google { background: #fef2f2; color: #dc2626; }
        .meta { background: #eff6ff; color: #2563eb; }
        .amazon { background: #fff7ed; color: #c2410c; }
        .microsoft { background: #f5f3ff; color: #7c3aed; }

        .difficulty {
            float: right;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .easy { color: #22c55e; }
        .medium { color: #f59e0b; }
        .hard { color: #ef4444; }

        .question-title {
            font-size: 1.2rem;
            margin: 1rem 0;
            color: #0f172a;
        }

        .answer-section {
            background: #f8fafc;
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
            display: none;
        }

        .answer-section.show {
            display: block;
        }

        .code-block {
            background: #1e1e1e;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
        }

        .tips-section {
            background: #f0f9ff;
            border-left: 4px solid #3b82f6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .show-answer-btn {
            background: var(--gradient-2);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.3s ease;
        }

        .show-answer-btn:hover {
            opacity: 0.9;
        }

        .tags {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .tag {
            background: #e2e8f0;
            padding: 0.3rem 0.8rem;
            border-radius: 50px;
            font-size: 0.8rem;
            color: #475569;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
            
            .question-card {
                padding: 1.5rem;
            }
        }

        /* Add this to your existing CSS */
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: var(--gradient-1);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            /* Added white outline */
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
            opacity: 0.9;
            /* Make border more visible on hover */
            border-color: rgba(255, 255, 255, 0.8);
        }

        .back-button svg {
            width: 20px;
            height: 20px;
            stroke: white;
        }

        /* Make it responsive */
        @media (max-width: 768px) {
            .back-button {
                top: 10px;
                left: 10px;
                padding: 8px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <!-- Add this near the top of your body, before the hero section -->
    <a href="test.html" class="back-button">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="19" y1="12" x2="5" y2="12"></line>
            <polyline points="12 19 5 12 12 5"></polyline>
        </svg>
        Back
    </a>

    <div class="hero">
        <h1> CODE-MASTER <br>Off-Campus Interview Prep</h1>
        <p>Master the most asked Python questions in top tech companies <br>
        Don't miss out on your dream! </p>
        <div class="quick-filters">
            <button class="filter-btn" data-filter="all">All Questions</button>
            <button class="filter-btn" data-filter="easy">Easy</button>
            <button class="filter-btn" data-filter="medium">Medium</button>
            <button class="filter-btn" data-filter="hard">Hard</button>
            <button class="filter-btn" data-company="google">Google</button>
            <button class="filter-btn" data-company="meta">Meta</button>
            <button class="filter-btn" data-company="amazon">Amazon</button>
        </div>
    </div>

    <div class="container">
        <!-- Question 1 -->
        <div class="question-card" data-difficulty="medium" data-company="instagram">
            <span class="company-tag instagram">Instagram</span>
            <span class="difficulty medium">Medium</span>
            <h3 class="question-title">1. Explain Python's GIL (Global Interpreter Lock) and its impact on multithreading</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(1)">Show Answer</button>
            
            <div id="answer1" class="answer-section">
                <div class="explanation-section">
                    <p>The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple native threads from executing Python bytecodes simultaneously. This is how Python ensures thread safety and manages memory.</p>
                    <ul>
                        <li>Only one thread can execute Python code at a time</li>
                        <li>The GIL is released during I/O operations</li>
                        <li>CPU-bound tasks are affected more than I/O-bound tasks</li>
                        <li>Multiprocessing can be used to bypass the GIL</li>
                    </ul>
                </div>

                <div class="code-block">
                    import threading
                    import time

                    def cpu_bound_task():
                        count = 0
                        for i in range(100_000_000):
                            count += 1

                    # Single thread
                    start = time.time()
                    cpu_bound_task()
                    cpu_bound_task()
                    print(f"Sequential: {time.time() - start}")

                    # Multiple threads
                    start = time.time()
                    t1 = threading.Thread(target=cpu_bound_task)
                    t2 = threading.Thread(target=cpu_bound_task)
                    t1.start()
                    t2.start()
                    t1.join()
                    t2.join()
                    print(f"Threaded: {time.time() - start}")

                    # Note: The threaded version might not be faster due to GIL!
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Use multiprocessing for CPU-bound tasks</li>
                        <li>Use threading for I/O-bound tasks</li>
                        <li>Consider async/await for I/O-bound operations</li>
                        <li>Use C extensions to release the GIL when needed</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Pitfalls:</strong>
                    <ul>
                        <li>Using threads for CPU-intensive tasks</li>
                        <li>Not understanding GIL's impact on performance</li>
                        <li>Assuming more threads always mean better performance</li>
                        <li>Not considering alternative approaches (asyncio, multiprocessing)</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Threading</span>
                <span class="tag">Performance</span>
                <span class="tag">Concurrency</span>
            </div>
        </div>

        <!-- Question 2 -->
        <div class="question-card" data-difficulty="hard" data-company="google">
            <span class="company-tag google">Google</span>
            <span class="difficulty hard">Hard</span>
            <h3 class="question-title">2. Explain Python's Memory Management and Garbage Collection</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(2)">Show Answer</button>
            
            <div id="answer2" class="answer-section">
                <div class="explanation-section">
                    <p>Python's memory management is handled by the Python Memory Manager. Memory allocation and deallocation are automated through reference counting and garbage collection.</p>
                    <ul>
                        <li>Private heap space contains all Python objects</li>
                        <li>Reference counting tracks object references</li>
                        <li>Garbage collector handles circular references</li>
                        <li>Memory pooling optimizes small object allocation</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Memory allocation example
                    x = 300  # Stored in private heap
                    y = 300  # Points to same object (integer caching)
                    print(id(x) == id(y))  # True

                    # Reference counting example
                    import sys
                    my_list = [1, 2, 3]
                    print(sys.getrefcount(my_list) - 1)  # Get reference count

                    # Circular reference example
                    class Node:
                        def __init__(self):
                            self.next = None

                    node1 = Node()
                    node2 = Node()
                    node1.next = node2
                    node2.next = node1  # Creates circular reference

                    # Manual garbage collection
                    import gc
                    gc.collect()  # Force garbage collection
                </div>

                <div class="tips-section">
                    <strong>Key Concepts:</strong>
                    <ul>
                        <li>Objects are allocated in private heap space</li>
                        <li>Reference counting for immediate cleanup</li>
                        <li>Generational garbage collection for cycles</li>
                        <li>Memory pooling for small objects</li>
                        <li>Object interning for small integers and strings</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Memory Issues:</strong>
                    <ul>
                        <li>Memory leaks from circular references</li>
                        <li>Not closing file handles or connections</li>
                        <li>Large objects in memory too long</li>
                        <li>Not using context managers for cleanup</li>
                        <li>Keeping unnecessary references to large objects</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Memory</span>
                <span class="tag">GC</span>
                <span class="tag">Internals</span>
            </div>
        </div>

        <!-- Question 3 -->
        <div class="question-card" data-difficulty="medium" data-company="microsoft">
            <span class="company-tag microsoft">Microsoft</span>
            <span class="difficulty medium">Medium</span>
            <h3 class="question-title">3. How do you implement proper error handling in Python?</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(3)">Show Answer</button>
            
            <div id="answer3" class="answer-section">
                <div class="explanation-section">
                    <p>Python's error handling is based on the try-except pattern, with additional features for cleanup and custom exceptions. Proper error handling is crucial for writing robust and maintainable code.</p>
                    <ul>
                        <li>try-except blocks for basic error handling</li>
                        <li>else clause for successful execution code</li>
                        <li>finally clause for cleanup</li>
                        <li>Custom exceptions for specific error cases</li>
                        <li>Context managers for resource management</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Custom exception
                    class ValidationError(Exception):
                        def __init__(self, message, errors):
                            super().__init__(message)
                            self.errors = errors

                    # Context manager example
                    class DatabaseConnection:
                        def __enter__(self):
                            print("Opening connection")
                            return self

                        def __exit__(self, exc_type, exc_val, exc_tb):
                            print("Closing connection")
                            return False  # Don't suppress exceptions

                    # Complete error handling example
                    def process_data(data):
                        try:
                            with DatabaseConnection() as db:
                                if not validate_data(data):
                                    raise ValidationError("Invalid data", 
                                               errors=["field1", "field2"])
                                # Process data
                        except ValidationError as e:
                            print(f"Validation failed: {e.errors}")
                            return False
                        except Exception as e:
                            print(f"Unexpected error: {e}")
                            raise  # Re-raise unexpected exceptions
                        else:
                            print("Success!")
                            return True
                        finally:
                            print("Cleanup code")
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Always catch specific exceptions</li>
                        <li>Use context managers for resources</li>
                        <li>Create custom exceptions when needed</li>
                        <li>Include cleanup in finally blocks</li>
                        <li>Document expected exceptions</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Pitfalls:</strong>
                    <ul>
                        <li>Using bare except clauses</li>
                        <li>Silently passing exceptions</li>
                        <li>Not cleaning up resources</li>
                        <li>Catching exceptions too broadly</li>
                        <li>Not documenting error conditions</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Exceptions</span>
                <span class="tag">Error Handling</span>
                <span class="tag">Best Practices</span>
            </div>
        </div>

        <!-- Question 4 -->
        <div class="question-card" data-difficulty="easy" data-company="amazon">
            <span class="company-tag amazon">Amazon</span>
            <span class="difficulty easy">Easy</span>
            <h3 class="question-title">4. What are the differences between Python 2 and Python 3?</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(4)">Show Answer</button>
            
            <div id="answer4" class="answer-section">
                <div class="explanation-section">
                    <p>Python 3 introduced several breaking changes and improvements over Python 2. Understanding these differences is crucial for code migration and maintenance.</p>
                    <strong>Major Changes:</strong>
                    <ul>
                        <li>Print is now a function instead of a statement</li>
                        <li>Division operator behavior changed</li>
                        <li>Unicode strings by default</li>
                        <li>Iterator objects instead of lists in many cases</li>
                        <li>New syntax features and standard library reorganization</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Python 2 vs Python 3 Examples

                    # 1. Print Statement vs Function
                    # Python 2
                    print "Hello"  # Statement
                    print "Multiple", "Arguments"  # Comma-separated
                    
                    # Python 3
                    print("Hello")  # Function call
                    print("Multiple", "Arguments")  # Multiple arguments
                    print("With end", end="")  # New keyword arguments
                    
                    # 2. Division Operator
                    # Python 2
                    result = 3 / 2    # Returns 1 (integer division)
                    result = 3 // 2   # Returns 1 (floor division)
                    
                    # Python 3
                    result = 3 / 2    # Returns 1.5 (true division)
                    result = 3 // 2   # Returns 1 (floor division)
                    
                    # 3. String Types
                    # Python 2
                    str_ascii = "Hello"          # ASCII by default
                    str_unicode = u"Hello"       # Unicode string
                    
                    # Python 3
                    str_unicode = "Hello"        # Unicode by default
                    str_bytes = b"Hello"         # Bytes string
                    
                    # 4. Range vs xrange
                    # Python 2
                    xrange_obj = xrange(1000)    # Returns iterator
                    range_obj = range(1000)      # Returns list
                    
                    # Python 3
                    range_obj = range(1000)      # Returns iterator
                    list_obj = list(range(1000)) # Convert to list if needed
                </div>

                <div class="tips-section">
                    <strong>Migration Tips:</strong>
                    <ul>
                        <li>Use `2to3` tool for automated conversion</li>
                        <li>Write compatible code using `__future__` imports</li>
                        <li>Test thoroughly after migration</li>
                        <li>Use modern Python features when possible</li>
                        <li>Consider dependencies compatibility</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Migration Issues:</strong>
                    <ul>
                        <li>String encoding/decoding problems</li>
                        <li>Division operator behavior changes</li>
                        <li>Print statement syntax</li>
                        <li>Iterator vs list behavior</li>
                        <li>Library compatibility issues</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Python2</span>
                <span class="tag">Python3</span>
                <span class="tag">Migration</span>
            </div>
        </div>

        <!-- Question 5 -->
        <div class="question-card" data-difficulty="medium" data-company="netflix">
            <span class="company-tag netflix">Netflix</span>
            <span class="difficulty medium">Medium</span>
            <h3 class="question-title">5. Explain Python decorators and their use cases</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(5)">Show Answer</button>
            
            <div id="answer5" class="answer-section">
                <div class="explanation-section">
                    <p>Decorators are a powerful way to modify or enhance functions or classes without directly changing their source code. They use the @syntax and are implemented as callable objects.</p>
                    <strong>Types of Decorators:</strong>
                    <ul>
                        <li>Function decorators</li>
                        <li>Class decorators</li>
                        <li>Decorators with arguments</li>
                        <li>Method decorators</li>
                        <li>Property decorators</li>
                    </ul>
                </div>

                <div class="code-block">
                    import functools
                    import time

                    # Simple decorator
                    def timer(func):
                        @functools.wraps(func)  # Preserves function metadata
                        def wrapper(*args, **kwargs):
                            start = time.time()
                            result = func(*args, **kwargs)
                            print(f"Time taken: {time.time() - start:.2f} seconds")
                            return result
                        return wrapper

                    # Decorator with arguments
                    def retry(attempts=3, delay=1):
                        def decorator(func):
                            @functools.wraps(func)
                            def wrapper(*args, **kwargs):
                                for i in range(attempts):
                                    try:
                                        return func(*args, **kwargs)
                                    except Exception as e:
                                        if i == attempts - 1:
                                            raise
                                        time.sleep(delay)
                        return decorator

                    # Usage examples
                    @timer
                    def slow_function():
                        time.sleep(1)

                    @retry(attempts=3)
                    def unreliable_function():
                        # Might fail sometimes
                        pass

                    # Class decorator
                    def singleton(cls):
                        instances = {}
                        def get_instance(*args, **kwargs):
                            if cls not in instances:
                                instances[cls] = cls(*args, **kwargs)
                            return instances[cls]
                        return get_instance
                </div>

                <div class="tips-section">
                    <strong>Common Use Cases:</strong>
                    <ul>
                        <li>Timing and profiling</li>
                        <li>Access control and authentication</li>
                        <li>Logging and debugging</li>
                        <li>Caching and memoization</li>
                        <li>Input validation and type checking</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Not using @functools.wraps</li>
                        <li>Modifying function arguments incorrectly</li>
                        <li>Decorator order matters</li>
                        <li>Memory leaks in memoization decorators</li>
                        <li>Overusing decorators</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Decorators</span>
                <span class="tag">Metaprogramming</span>
                <span class="tag">Functions</span>
            </div>
        </div>

        <!-- Question 6 -->
        <div class="question-card" data-difficulty="medium" data-company="meta">
            <span class="company-tag meta">Meta</span>
            <span class="difficulty medium">Medium</span>
            <h3 class="question-title">6. What are Python generators and how do you use them?</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(6)">Show Answer</button>
            
            <div id="answer6" class="answer-section">
                <div class="explanation-section">
                    <p>Generators are special functions that return an iterator object. They use the yield keyword to generate a sequence of values lazily, making them memory-efficient for large datasets.</p>
                    <strong>Key Concepts:</strong>
                    <ul>
                        <li>Lazy evaluation</li>
                        <li>Memory efficiency</li>
                        <li>Iterator protocol</li>
                        <li>State preservation</li>
                        <li>Generator expressions</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Simple generator function
                    def fibonacci(n):
                        a, b = 0, 1
                        for _ in range(n):
                            yield a
                            a, b = b, a + b

                    # Generator expression
                    squares = (x*x for x in range(1000))

                    # Memory comparison
                    import sys
                    list_comp = [x*x for x in range(1000)]
                    gen_exp = (x*x for x in range(1000))
                    print(f"List size: {sys.getsizeof(list_comp)}")
                    print(f"Generator size: {sys.getsizeof(gen_exp)}")

                    # Infinite sequence generator
                    def infinite_counter():
                        i = 0
                        while True:
                            yield i
                            i += 1

                    # Generator with send()
                    def counter():
                        i = 0
                        while True:
                            val = yield i
                            if val is not None:
                                i = val
                            else:
                                i += 1
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Use generators for large sequences</li>
                        <li>Consider memory usage</li>
                        <li>Use generator expressions for simple cases</li>
                        <li>Chain generators with itertools</li>
                        <li>Document generator behavior</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Trying to reuse exhausted generators</li>
                        <li>Converting generators to lists unnecessarily</li>
                        <li>Not handling StopIteration</li>
                        <li>Memory leaks in infinite generators</li>
                        <li>Confusion with return vs yield</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Generators</span>
                <span class="tag">Iterators</span>
                <span class="tag">Memory</span>
            </div>
        </div>

        <!-- Question 7 -->
        <div class="question-card" data-difficulty="easy" data-company="amazon">
            <span class="company-tag amazon">Amazon</span>
            <span class="difficulty easy">Easy</span>
            <h3 class="question-title">7. Explain list comprehensions and their advantages</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(7)">Show Answer</button>
            
            <div id="answer7" class="answer-section">
                <div class="explanation-section">
                    <p>List comprehensions provide a concise way to create lists based on existing sequences or iterables. They combine the for loop and list creation into a single line of readable code.</p>
                    <strong>Key Features:</strong>
                    <ul>
                        <li>More concise than traditional loops</li>
                        <li>Better performance in most cases</li>
                        <li>Can include conditions and nested loops</li>
                        <li>Available for lists, sets, and dictionaries</li>
                        <li>Improved readability for simple operations</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Basic list comprehension
                    squares = [x**2 for x in range(10)]
                    
                    # With condition
                    even_squares = [x**2 for x in range(10) if x % 2 == 0]
                    
                    # Nested loops
                    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
                    flattened = [num for row in matrix for num in row]
                    
                    # Dictionary comprehension
                    square_dict = {x: x**2 for x in range(5)}
                    
                    # Set comprehension
                    unique_squares = {x**2 for x in range(10)}
                    
                    # Compare with traditional loop
                    squares_traditional = []
                    for x in range(10):
                        if x % 2 == 0:
                            squares_traditional.append(x**2)
                            
                    # Same as
                    squares_comprehension = [x**2 for x in range(10) if x % 2 == 0]
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Keep comprehensions simple and readable</li>
                        <li>Avoid multiple conditions or complex operations</li>
                        <li>Consider generator expressions for large sequences</li>
                        <li>Use meaningful variable names</li>
                        <li>Break complex comprehensions into multiple steps</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Writing overly complex comprehensions</li>
                        <li>Using comprehensions for side effects</li>
                        <li>Creating large lists in memory unnecessarily</li>
                        <li>Nesting too many loops</li>
                        <li>Sacrificing readability for brevity</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Lists</span>
                <span class="tag">Comprehensions</span>
                <span class="tag">Performance</span>
            </div>
        </div>

        <!-- Question 8 -->
        <div class="question-card" data-difficulty="hard" data-company="google">
            <span class="company-tag google">Google</span>
            <span class="difficulty hard">Hard</span>
            <h3 class="question-title">8. What are Python metaclasses and when would you use them?</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(8)">Show Answer</button>
            
            <div id="answer8" class="answer-section">
                <div class="explanation-section">
                    <p>Metaclasses are classes for classes - they allow you to customize class creation. They're used to modify class behavior at definition time.</p>
                    <strong>Use Cases:</strong>
                    <ul>
                        <li>Abstract Base Classes</li>
                        <li>Class Registration</li>
                        <li>Interface Checking</li>
                        <li>Attribute Validation</li>
                        <li>Class Decoration</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Basic metaclass example
                    class MetaLogger(type):
                        def __new__(cls, name, bases, attrs):
                            # Add logging to all methods
                            for key, value in attrs.items():
                                if callable(value):
                                    attrs[key] = cls.log_call(value)
                            return super().__new__(cls, name, bases, attrs)
                        
                        @staticmethod
                        def log_call(func):
                            def wrapper(*args, **kwargs):
                                print(f"Calling {func.__name__}")
                                result = func(*args, **kwargs)
                                print(f"Finished {func.__name__}")
                                return result
                            return wrapper

                    # Using the metaclass
                    class MyClass(metaclass=MetaLogger):
                        def some_method(self):
                            print("Method execution")

                    # Abstract Base Class example
                    class Interface(metaclass=abc.ABCMeta):
                        @abc.abstractmethod
                        def my_method(self):
                            pass

                    # Singleton using metaclass
                    class Singleton(type):
                        _instances = {}
                        def __call__(cls, *args, **kwargs):
                            if cls not in cls._instances:
                                cls._instances[cls] = super().__call__(*args, **kwargs)
                            return cls._instances[cls]
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Use metaclasses sparingly</li>
                        <li>Document metaclass behavior clearly</li>
                        <li>Consider simpler alternatives first</li>
                        <li>Keep metaclasses focused and single-purpose</li>
                        <li>Test metaclass behavior thoroughly</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Overusing metaclasses</li>
                        <li>Making metaclasses too complex</li>
                        <li>Not handling inheritance properly</li>
                        <li>Forgetting to call super()</li>
                        <li>Poor documentation of metaclass behavior</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Metaclasses</span>
                <span class="tag">OOP</span>
                <span class="tag">Advanced</span>
            </div>
        </div>

        <!-- Question 9 -->
        <div class="question-card" data-difficulty="medium" data-company="meta">
            <span class="company-tag meta">Meta</span>
            <span class="difficulty medium">Medium</span>
            <h3 class="question-title">9. How does Python's context manager (with statement) work?</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(9)">Show Answer</button>
            
            <div id="answer9" class="answer-section">
                <div class="explanation-section">
                    <p>Context managers provide a clean way to handle resource management (like file handling, database connections, etc.) with proper setup and cleanup. They implement the __enter__ and __exit__ methods.</p>
                    <strong>Key Components:</strong>
                    <ul>
                        <li>__enter__: Setup resource</li>
                        <li>__exit__: Cleanup resource</li>
                        <li>contextlib module utilities</li>
                        <li>Nested context managers</li>
                        <li>Exception handling</li>
                    </ul>
                </div>

                <div class="code-block">
                    # Basic context manager
                    class FileManager:
                        def __init__(self, filename, mode):
                            self.filename = filename
                            self.mode = mode
                            self.file = None
                        
                        def __enter__(self):
                            self.file = open(self.filename, self.mode)
                            return self.file
                        
                        def __exit__(self, exc_type, exc_val, exc_tb):
                            if self.file:
                                self.file.close()
                            return False  # Don't suppress exceptions

                    # Using the context manager
                    with FileManager('test.txt', 'w') as f:
                        f.write('Hello, World!')

                    # Using contextlib
                    from contextlib import contextmanager

                    @contextmanager
                    def timer():
                        import time
                        start = time.time()
                        yield
                        print(f"Elapsed: {time.time() - start}")

                    # Multiple context managers
                    with open('input.txt') as in_file, open('output.txt', 'w') as out_file:
                        content = in_file.read()
                        out_file.write(content.upper())
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Always close resources in __exit__</li>
                        <li>Handle exceptions appropriately</li>
                        <li>Use contextlib for simple cases</li>
                        <li>Document resource management behavior</li>
                        <li>Consider using async context managers when needed</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Forgetting to close resources</li>
                        <li>Suppressing exceptions incorrectly</li>
                        <li>Not handling nested contexts properly</li>
                        <li>Missing cleanup in error cases</li>
                        <li>Resource leaks in __enter__</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Context Managers</span>
                <span class="tag">Resource Management</span>
                <span class="tag">Files</span>
            </div>
        </div>

        <!-- Question 10 -->
        <div class="question-card" data-difficulty="hard" data-company="netflix">
            <span class="company-tag netflix">Netflix</span>
            <span class="difficulty hard">Hard</span>
            <h3 class="question-title">10. Explain Python's asyncio and asynchronous programming</h3>
            
            <button class="show-answer-btn" onclick="toggleAnswer(10)">Show Answer</button>
            
            <div id="answer10" class="answer-section">
                <div class="explanation-section">
                    <p>Asyncio is Python's built-in library for writing asynchronous code using coroutines, event loops, and tasks. It's particularly useful for I/O-bound operations.</p>
                    <strong>Key Concepts:</strong>
                    <ul>
                        <li>Coroutines (async/await)</li>
                        <li>Event Loop</li>
                        <li>Tasks and Futures</li>
                        <li>Asynchronous Context Managers</li>
                        <li>Asynchronous Iterators</li>
                    </ul>
                </div>

                <div class="code-block">
                    import asyncio
                    import aiohttp
                    
                    # Basic coroutine
                    async def fetch_data(url):
                        async with aiohttp.ClientSession() as session:
                            async with session.get(url) as response:
                                return await response.text()

                    # Running multiple coroutines
                    async def main():
                        urls = [
                            'http://api.example.com/data1',
                            'http://api.example.com/data2',
                            'http://api.example.com/data3'
                        ]
                        tasks = [fetch_data(url) for url in urls]
                        results = await asyncio.gather(*tasks)
                        return results

                    # Event loop usage
                    if __name__ == "__main__":
                        asyncio.run(main())

                    # Async context manager
                    class AsyncResource:
                        async def __aenter__(self):
                            await self.open()
                            return self

                        async def __aexit__(self, exc_type, exc, tb):
                            await self.close()

                    # Async iterator
                    class AsyncRange:
                        def __init__(self, start, stop):
                            self.start = start
                            self.stop = stop

                        def __aiter__(self):
                            return self

                        async def __anext__(self):
                            if self.start >= self.stop:
                                raise StopAsyncIteration
                            self.start += 1
                            await asyncio.sleep(1)
                            return self.start - 1
                </div>

                <div class="tips-section">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Use asyncio for I/O-bound operations</li>
                        <li>Avoid blocking calls in coroutines</li>
                        <li>Handle exceptions in async code</li>
                        <li>Use proper async libraries (aiohttp, asyncpg)</li>
                        <li>Structure code for concurrency</li>
                    </ul>
                </div>

                <div class="common-pitfalls">
                    <strong>Common Mistakes:</strong>
                    <ul>
                        <li>Mixing sync and async code</li>
                        <li>Blocking the event loop</li>
                        <li>Not handling coroutine exceptions</li>
                        <li>Forgetting to await coroutines</li>
                        <li>Creating too many tasks</li>
                    </ul>
                </div>
            </div>
            <div class="tags">
                <span class="tag">Asyncio</span>
                <span class="tag">Concurrency</span>
                <span class="tag">Advanced</span>
            </div>
        </div>

        <!-- Add more questions following the same pattern -->

    </div>

    <script>
        // Toggle answer visibility
        function toggleAnswer(id) {
            const answer = document.getElementById('answer' + id);
            const button = answer.previousElementSibling;
            answer.classList.toggle('show');
            button.textContent = answer.classList.contains('show') ? 'Hide Answer' : 'Show Answer';
        }

        // Filter functionality
        document.querySelectorAll('.filter-btn').forEach(button => {
            button.addEventListener('click', () => {
                const filter = button.dataset.filter;
                const company = button.dataset.company;
                
                document.querySelectorAll('.question-card').forEach(card => {
                    if (filter === 'all') {
                        card.style.display = 'block';
                    } else if (filter) {
                        card.style.display = card.dataset.difficulty === filter ? 'block' : 'none';
                    } else if (company) {
                        card.style.display = card.dataset.company === company ? 'block' : 'none';
                    }
                });
            });
        });
    </script>
</body>
</html>
